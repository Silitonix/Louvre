<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Louvre: Chapter 7: Surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Louvre
   &#160;<span id="projectnumber">v2.4.0-1</span>
   </div>
   <div id="projectbrief">C++ library for Wayland compositors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Chapter 7: Surfaces </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_md_tutorial_07"></a> You may already have an idea of what a surface is, but let's clarify it. Think of a surface as a canvas created by a Wayland client, which the compositor can render on the screen. The client can request the compositor to use it as a cursor, a drag &amp; drop icon, a toplevel window, and so on. This specific use assigned by the client is known as the surface role. Each surface role provides rules on how the compositor should position, stack, and interact with the surface. Refer to the <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">Louvre::LSurface</a> documentation for additional information on the available roles.</p>
<p>You can determine the assigned role of a surface using <a class="el" href="class_louvre_1_1_l_surface.html#a740a064ccce3e2cd36c7c843d346890a" title="ID of the role.">Louvre::LSurface::roleId()</a> and access it through <a class="el" href="class_louvre_1_1_l_surface.html#adcb0a0c7570cedec2cc38822943a7fff" title="Surface role.">Louvre::LSurface::role()</a>. Alternatively, you can directly cast it using methods like <a class="el" href="class_louvre_1_1_l_surface.html#a2486948f8e54c31d79de22f79766d9ea" title="Cursor role.">Louvre::LSurface::cursorRole()</a>, <a class="el" href="class_louvre_1_1_l_surface.html#aaeabbba055c54e5881a8225a63a6b4c7" title="Drag &amp; Drop icon role.">Louvre::LSurface::dndIcon()</a>, <a class="el" href="class_louvre_1_1_l_surface.html#a744809727c631248ae26aae91fa08a6d" title="Toplevel role.">Louvre::LSurface::toplevel()</a>, etc.<br  />
</p>
<blockquote class="doxtable">
<p>All surface roles are derived from the <a class="el" href="class_louvre_1_1_l_base_surface_role.html" title="Base class for surface roles.">Louvre::LBaseSurfaceRole</a> class. </p>
</blockquote>
<p>For example, to check if a surface has a toplevel role, you can use <a class="el" href="class_louvre_1_1_l_surface.html#a744809727c631248ae26aae91fa08a6d" title="Toplevel role.">Louvre::LSurface::toplevel()</a>, which may return an <a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">Louvre::LToplevelRole</a> instance or <code>nullptr</code> if it has a different role or none at all. We will delve into the details of each specific role in future chapters, so please be patient.</p>
<h2><a class="anchor" id="autotoc_md157"></a>
Position</h2>
<p>As mentioned earlier, each role provides information on how the compositor should position the surface. Typically, this position is either a local offset relative to a parent surface or an offset relative to a position of your choice. For instance, toplevel surfaces for example, representing typical app windows with a title bar, close, minimize, and maximize buttons, often have window decorations such as shadows. When positioning a toplevel window, you want to place it relative to its top-left corner but ignore its decorations. This is why toplevels offer a window geometry rect (<a class="el" href="class_louvre_1_1_l_toplevel_role.html#a5769ecaee5ac98a0de4c63399b05aa37" title="Window geometry in surface coordinates.">Louvre::LToplevelRole::windowGeometry()</a>) that specifies which part of its texture belongs to the window and which part constitutes decorations.</p>
<center> <img src="https://lh3.googleusercontent.com/pw/AIL4fc9WuCZOWGGC6v7ZepWA7VOWygycmNFEngEHX7J9ODdmzm1Qs4au1KYPMRJ_102tfvOXFBcL-Kwghm0bSKbd4U6der3p94l1drpn3ONqb9yfv-uFgHQ=w2400" alt="" style="width:25vw" class="inline"/> </center><p>The role doesn't dictate where to position the toplevel but provides the offset necessary for correct positioning.</p>
<p>To set the position of a surface, you can use <a class="el" href="class_louvre_1_1_l_surface.html#aef41c6d77555ec63040c5baa94f3ffff" title="Assigns the position.">Louvre::LSurface::setPos()</a>. If you then call <a class="el" href="class_louvre_1_1_l_surface.html#a0843c1bb97b8a8cfb3faa6f75e68acd6" title="Position given by the compositor.">Louvre::LSurface::pos()</a>, it will return the same position. However, if you call <a class="el" href="class_louvre_1_1_l_surface.html#adb14a727889d37b9b51c18a9a54745eb" title="Role position.">Louvre::LSurface::rolePos()</a> and the surface has a toplevel role, it will return the position you assigned minus the decoration offset. In this case, <a class="el" href="class_louvre_1_1_l_surface.html#adb14a727889d37b9b51c18a9a54745eb" title="Role position.">Louvre::LSurface::rolePos()</a> internally invokes <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a3f84761bc849ed17f4721f9eeedf74b2" title="Position of the surface according to the role.">Louvre::LToplevelRole::rolePos()</a>. <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> implements the default position logic for each role, but you have the option to override it if needed. However, it's worth noting that certain positioning rules can be challenging to implement, such as <a class="el" href="class_louvre_1_1_l_popup_role.html#a3f84761bc849ed17f4721f9eeedf74b2" title="Position of the popup surface according to the role.">Louvre::LPopupRole::rolePos()</a>.</p>
<p>Now, let's consider another example: the subsurface role (<a class="el" href="class_louvre_1_1_l_subsurface_role.html" title="Subsurface role for surfaces.">Louvre::LSubsurfaceRole</a>). A subsurface is always a child of another surface and is positioned relative to the parent surface's position. In this case, the position set with <a class="el" href="class_louvre_1_1_l_surface.html#aef41c6d77555ec63040c5baa94f3ffff" title="Assigns the position.">Louvre::LSurface::setPos()</a> is disregarded, and <a class="el" href="class_louvre_1_1_l_surface.html#adb14a727889d37b9b51c18a9a54745eb" title="Role position.">Louvre::LSurface::rolePos()</a> simply returns the parent surface's position plus the offset defined by the client (check <a class="el" href="class_louvre_1_1_l_subsurface_role.html#a3f84761bc849ed17f4721f9eeedf74b2" title="Position of the subsurface according to the role.">Louvre::LSubsurfaceRole::rolePos()</a>).</p>
<p>In summary, employ <a class="el" href="class_louvre_1_1_l_surface.html#aef41c6d77555ec63040c5baa94f3ffff" title="Assigns the position.">Louvre::LSurface::setPos()</a> to define the surface position without applying any additional role position rules. And use <a class="el" href="class_louvre_1_1_l_surface.html#adb14a727889d37b9b51c18a9a54745eb" title="Role position.">Louvre::LSurface::rolePos()</a> to retrieve the actual position when rendering its texture.</p>
<h2><a class="anchor" id="autotoc_md158"></a>
Size and Scale</h2>
<p>A surface's size is determined by its texture size and its scale. When you use <a class="el" href="class_louvre_1_1_l_surface.html#a9595879ae0c4def717bd69d345001ed0" title="Surface size in buffer coordinates.">Louvre::LSurface::sizeB()</a>, it returns the texture size, disregarding the scale. Conversely, <a class="el" href="class_louvre_1_1_l_surface.html#af0e9483bc8188a275f4877e55ec720b0" title="Surface size in surface coordinates.">Louvre::LSurface::size()</a> provides the size in surface coordinates, which is the texture size divided by the scale.</p>
<p>Just as we've seen with outputs, a client may render the surface content into a HiDPI buffer when displayed on a HiDPI output. In such cases, it informs us that it's using a scale of 2 (or greater), allowing us to render it properly.</p>
<blockquote class="doxtable">
<p>Since <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> 1.2.0, the Viewporter and Fractional Scale protocols have been introduced. With these protocols, clients are now allowed to define a custom rect of their texture to use as a source and scale it to any arbitrary size, thereby removing the direct relationship of <a class="el" href="class_louvre_1_1_l_surface.html#af0e9483bc8188a275f4877e55ec720b0" title="Surface size in surface coordinates.">Louvre::LSurface::size()</a> with the buffer size and scale. However, this does not affect how you need to handle their rendering. You can continue using <a class="el" href="class_louvre_1_1_l_surface.html#aa62271a8aeb6886831d1a59b5d73b1b5" title="Gets the source rect of the surface in surface coordinates.">Louvre::LSurface::srcRect()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#af0e9483bc8188a275f4877e55ec720b0" title="Surface size in surface coordinates.">Louvre::LSurface::size()</a> as always. Additionally, properties such as input, opaque, translucent, and damage regions are automatically scaled to the specified <a class="el" href="class_louvre_1_1_l_surface.html#af0e9483bc8188a275f4877e55ec720b0" title="Surface size in surface coordinates.">Louvre::LSurface::size()</a> by <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a>. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md159"></a>
Stacking Order</h2>
<p>As we've seen before, the <a class="el" href="class_louvre_1_1_l_compositor.html" title="Louvre&#39;s core and objects factory.">Louvre::LCompositor</a> class maintains a list of all client surfaces (<a class="el" href="class_louvre_1_1_l_compositor.html#a02b82f9077f93ed98b9fdd2c963014e8" title="Gets a list of all surfaces created by clients.">Louvre::LCompositor::surfaces()</a>) that defines their stacking order.<br  />
Certain surface roles require us to adhere to their provided stacking order, such as <a class="el" href="class_louvre_1_1_l_subsurface_role.html" title="Subsurface role for surfaces.">Louvre::LSubsurfaceRole</a> and <a class="el" href="class_louvre_1_1_l_popup_role.html" title="Popup role for surfaces.">Louvre::LPopupRole</a>.<br  />
As illustrated in the following image, you can observe a cluster of popups, with each one neatly stacked on top of its parent popup.</p>
<center> <img src="https://lh3.googleusercontent.com/6caGayutKKWqndpd6ogno2lPw8XGELxnFums4gvkWZKOJYO0762yVG3mHLrc1rw63r1eEJabEdW9F5AA2BDTFCtpB_hiPlTY4FkKlHfH1B-2MdLvXCD6RuwZOZvhOl6EhydtsOYGPw=w2400" alt="" style="width:35vw" class="inline"/> </center><p>You have the flexibility to modify this order tho, for example, by calling <a class="el" href="class_louvre_1_1_l_surface.html#ad9c27f2d106edb222bc33c4bfc384f58" title="Raises the surface within its current layer.">Louvre::LSurface::raise()</a>. This action brings the specified surface to the top while ensuring that the stacking order of its role (or other surfaces' roles) is respected, so it may raise other surfaces as well.</p>
<p>Additionally, you can detect when the order of a surface changes in the list, overriding the <a class="el" href="class_louvre_1_1_l_surface.html#ac30d215881c074b2cab7d90e5d54e149" title="Notifies when the surface changes its position in the surfaces list.">Louvre::LSurface::orderChanged()</a> virtual method.</p>
<p>To determine which surface is positioned behind or in front of a particular surface, you can use <a class="el" href="class_louvre_1_1_l_surface.html#a011aa286f1843209432e721d51304810" title="Retrieve the previous surface in the compositor surfaces list (LCompositor::surfaces()).">Louvre::LSurface::prevSurface()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#aa2df3baf64b05fa8b629b3eaefc59c5d" title="Retrieve the next surface in the compositor surfaces list (LCompositor::surfaces()).">Louvre::LSurface::nextSurface()</a>. However, be careful, as these methods might return <code>nullptr</code> if the surface is at the beginning or end of the surfaces list.</p>
<blockquote class="doxtable">
<p>You should never call <a class="el" href="class_louvre_1_1_l_surface.html#ad9c27f2d106edb222bc33c4bfc384f58" title="Raises the surface within its current layer.">Louvre::LSurface::raise()</a> while iterating through the <a class="el" href="class_louvre_1_1_l_compositor.html#a02b82f9077f93ed98b9fdd2c963014e8" title="Gets a list of all surfaces created by clients.">Louvre::LCompositor::surfaces()</a> list, as doing so could result in a segfault. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md160"></a>
Rendering Surfaces</h1>
<p>Hoping that all that theory didn't bore you to death, it's now time to delve into something more enjoyable â€“ rendering the surfaces in our scene. To achieve this, we'll make use of the <a class="el" href="class_louvre_1_1_l_surface_view.html" title="View for displaying surfaces.">Louvre::LSurfaceView</a>. This view inherits all the properties of the surface, like <a class="el" href="class_louvre_1_1_l_surface.html#adb14a727889d37b9b51c18a9a54745eb" title="Role position.">Louvre::LSurface::rolePos()</a> for positioning, <a class="el" href="class_louvre_1_1_l_surface.html#af0e9483bc8188a275f4877e55ec720b0" title="Surface size in surface coordinates.">Louvre::LSurface::size()</a> to determine its size, and other attributes like opaque/translucent regions, damage, and more.</p>
<p>So, let's get started by creating our very own <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">Louvre::LSurface</a> subclass, which we will of course name <code>ESurface</code>.</p>
<h3><a class="anchor" id="autotoc_md161"></a>
src/ESurface.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ESURFACE_H</span></div>
<div class="line"><span class="preprocessor">#define ESURFACE_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LSurface.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LSurfaceView.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ECompositor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ESurface : <span class="keyword">public</span> LSurface</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ESurface(<span class="keyword">const</span> <span class="keywordtype">void</span> *params);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> roleChanged() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> orderChanged() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    LSurfaceView view { (LSurface*) <span class="keyword">this</span>, &amp;G::compositor()-&gt;surfacesLayer };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// ESURFACE_H</span></div>
<div class="ttc" id="anamespace_louvre_html"><div class="ttname"><a href="namespace_louvre.html">Louvre</a></div><div class="ttdoc">Namespaces.</div><div class="ttdef"><b>Definition:</b> LBox.h:7</div></div>
</div><!-- fragment --><p>Here, we're overriding the <a class="el" href="class_louvre_1_1_l_surface.html#ad277475bd3c8656d83e5d221e5db4bf0" title="Notifies a change of role.">Louvre::LSurface::roleChanged()</a> event because we want to exclude certain roles from rendering, such as the cursor role.</p>
<p>Additionally, we're overriding <a class="el" href="class_louvre_1_1_l_surface.html#ac30d215881c074b2cab7d90e5d54e149" title="Notifies when the surface changes its position in the surfaces list.">Louvre::LSurface::orderChanged()</a>, which we will use for updating the views stacking order.</p>
<p>Lastly, we've introduced an <a class="el" href="class_louvre_1_1_l_surface_view.html" title="View for displaying surfaces.">Louvre::LSurfaceView</a> for this surface, adding it to the surfaces layer.</p>
<h3><a class="anchor" id="autotoc_md162"></a>
src/ESurface.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;LCursor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ESurface.h&quot;</span></div>
<div class="line"> </div>
<div class="line">ESurface::ESurface(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) : LSurface(params)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Detaches its position from its parent view</span></div>
<div class="line">    view.enableParentOffset(<span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ESurface::roleChanged()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Hide cursor surfaces because we use LCursor</span></div>
<div class="line">    <span class="keywordflow">if</span> (cursorRole())</div>
<div class="line">        view.setVisible(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Move drag &amp; drop icons to the cursor layer so they always</span></div>
<div class="line">    <span class="comment">// appear on top of other views</span></div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dndIcon())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Ensure it is positioned behind &#39;softwareCursor&#39;</span></div>
<div class="line">        view.setParent(&amp;G::compositor()-&gt;cursorLayer);</div>
<div class="line">        view.insertAfter(<span class="keyword">nullptr</span>, <span class="keyword">false</span>);</div>
<div class="line">        setPos(<a class="code" href="namespace_louvre.html#a0ebe6057a764ac1de2b90e50c6a7916c">cursor</a>()-&gt;pos());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ESurface::orderChanged()</div>
<div class="line">{</div>
<div class="line">    ESurface *prev { (ESurface*)prevSurface() };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Surfaces are ordered in a single list, however, our views</span></div>
<div class="line"><span class="comment">     * can be children of the surface, cursor, or fullscreen layers.</span></div>
<div class="line"><span class="comment">     * Therefore, if &#39;prev&#39; has a different parent, we need to continue searching. */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (prev &amp;&amp; prev-&gt;view.parent() != view.parent())</div>
<div class="line">        prev = (ESurface*)prev-&gt;prevSurface();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (prev)</div>
<div class="line">        view.insertAfter(&amp;prev-&gt;view, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If there is no prev surface with the same parent, insert it at the beginning of the current parent&#39;s children list</span></div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        view.insertAfter(<span class="keyword">nullptr</span>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_louvre_html_a0ebe6057a764ac1de2b90e50c6a7916c"><div class="ttname"><a href="namespace_louvre.html#a0ebe6057a764ac1de2b90e50c6a7916c">Louvre::cursor</a></div><div class="ttdeci">LCursor * cursor() noexcept</div><div class="ttdoc">Gets the compositor's cursor.</div><div class="ttdef"><b>Definition:</b> LCompositor.cpp:44</div></div>
</div><!-- fragment --><p>In the constructor, we initialize the <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">Louvre::LSurface</a> parent class and disable the <a class="el" href="class_louvre_1_1_l_view.html#a73a566cebff0ad06de6133a61b164cc5" title="Checks if pos() includes the parent&#39;s position.">Louvre::LView::parentOffsetEnabled()</a> property for the view, which is enabled by default. Disabling it means that when the scene retrieves the position of a view using <a class="el" href="class_louvre_1_1_l_view.html#a5ce2421b1014305277aa91204749e01f" title="Gets the current position of the view with applied transformations.">Louvre::LView::pos()</a>, the position we assigned won't be adjusted by the parent view's position. The position of the <a class="el" href="class_louvre_1_1_l_surface_view.html" title="View for displaying surfaces.">Louvre::LSurfaceView</a>, as mentioned earlier, is inherited from the surface role's position, which is already global. Therefore, we disable the parent offset to prevent any additional positioning adjustments.</p>
<p>Within the <a class="el" href="class_louvre_1_1_l_surface.html#ad277475bd3c8656d83e5d221e5db4bf0" title="Notifies a change of role.">Louvre::LSurface::roleChanged()</a> event we hide the views that get assigned the cursor role (remember that we are using <a class="el" href="class_louvre_1_1_l_cursor.html" title="Utility class for rendering cursors.">Louvre::LCursor</a> instead). We also move drag &amp; drop icon views to the cursor layer so that they always appear on top of the rest.</p>
<p>And in <a class="el" href="class_louvre_1_1_l_surface.html#ac30d215881c074b2cab7d90e5d54e149" title="Notifies when the surface changes its position in the surfaces list.">Louvre::LSurface::orderChanged()</a>, we update the view stacking order with <a class="el" href="class_louvre_1_1_l_view.html#ac3496d4b6903aebb9a5405c3d36166cd" title="Inserts the view after the specified &#39;prev&#39; view.">Louvre::LView::insertAfter()</a>. This inserts the view on top of the surface that precedes it in the surfaces list. If there's no previous surface, we pass <code>nullptr</code>, which places the view at the beginning of its parent's children list.<br  />
You might also notice the <code>false</code> second parameter. This setting prevents the view from changing its parent if the view we are inserting it after belongs to another parent.</p>
<p>Once more, to make <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> use our subclass, we need to override the Louvre::LCompositor::createSurfaceRequest() virtual constructor:</p>
<h3><a class="anchor" id="autotoc_md163"></a>
src/ECompositor.h</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Virtual constructors</span></div>
<div class="line">LOutput *createOutputRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) <span class="keyword">override</span>;</div>
<div class="line">LSurface *createSurfaceRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md164"></a>
src/ECompositor.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;ESurface.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">LSurface *ECompositor::createSurfaceRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ESurface(params);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>params</code> argument simply contains the resources required for <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> to correctly construct each <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">Louvre::LSurface</a> instance.</p>
<p>If you recompile and run the compositor now, you should see the application windows coming back to life. Also, don't forget that you can press <code>F1</code> to launch <code>weston-terminal</code> and <code>Ctrl + Shift + Esc</code> to exit the compositor.</p>
<p>Oh, and as you can clearly see in the screenshot, our windows just love to play hide-and-seek behind the topbar. It adds a certain charm, wouldn't you agree? ðŸ¥´</p>
<p><img src="https://lh3.googleusercontent.com/pw/ADCreHcHJvjtARnb8Vdm09fqb4kknHowY_-SlVlCXsYB1A3RKupGuCslPBDm7aMZXiv5nqVG-jFrXdUSueHWPDUO2cM4UzRs9ncCwCLsgk20eBEcEbAx8mQ=w2400" alt="" class="inline"/></p>
<p>We will address how to fix that later. In the meantime, I'll share a tip for checking if <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">Louvre::LScene</a> is drawing efficiently.<br  />
It's a good practice to use this trick occasionally to ensure it's working correctly, as there could be something causing inefficient rendering.</p>
<p>To do this, let's go to the <code>paintGL()</code> implementation in <code>EOutput.cpp</code> and clear the output screen before calling <a class="el" href="class_louvre_1_1_l_scene.html#a980646107c925c155e58646741a0fa8c" title="Handle the OpenGL painting for an LOutput.">Louvre::LScene::handlePaintGL()</a>.</p>
<h3><a class="anchor" id="autotoc_md165"></a>
src/ECompositor.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::paintGL()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    painter()-&gt;clearScreen();</div>
<div class="line">    G::scene()-&gt;handlePaintGL(<span class="keyword">this</span>);</div>
<div class="line"> </div>
<div class="line">    LRegion damage;</div>
<div class="line">    damage.addRect(rect());</div>
<div class="line">    setBufferDamage(&amp;damage);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><blockquote class="doxtable">
<p>We also need to call <a class="el" href="class_louvre_1_1_l_output.html#a7245d78b52786e2b77819860eab9a774" title="Specifies the damage generated during the last painGL() event.">Louvre::LOutput::setBufferDamage()</a> with a region encompassing the entire output rect. This serves as a hint to the graphic backend, informing it about the regions of the framebuffer that have been modified during the <code>paintGL()</code> event. This allows it to selectively copy those regions in certain scenarios, especially in multi-GPU systems where one of the GPUs cannot directly render to its own connectors (outputs) due to the inability to import surface textures, as it lacks <a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a> support. <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">Louvre::LScene</a> automatically calls this method with damage generated during <a class="el" href="class_louvre_1_1_l_scene.html#a980646107c925c155e58646741a0fa8c" title="Handle the OpenGL painting for an LOutput.">Louvre::LScene::handlePaintGL()</a>. However, because we called <a class="el" href="class_louvre_1_1_l_painter.html#a16454a37fc0a0427085de2800c218cf4" title="Clear the framebuffer.">Louvre::LPainter::clearScreen()</a> from outside, we need to manually include the entire damaged area. </p>
</blockquote>
<p>Recompile and run the compositor, then launch an app like <code>gedit</code>. You'll notice that only the parts of the window that change, such as when you hover the mouse over a button or move a window, are rendered. However, please note that <code>weston-terminal</code> is a poor example of a client because it damages its entire surface, even if only a small part of it changes.</p>
<p><img src="https://lh3.googleusercontent.com/pw/ADCreHeYAYKPI2HYT_TC_-lVn_Z3TEYbaGzKinQjWJWGTSEU_ls0ZH4qx8wysZybtha5pLx6UG-5tSF0NZqtTXUtm8xBkeqNtGnsd21D2A7kW-U3x2WilTo=w2400" alt="" class="inline"/></p>
<p>If you consistently observe that the entire screen or a great portion of it is being rendered in every frame, it is probable that there is an issue in your implementation. This might occur for example if you are frequently altering an output's position, adjusting a wallpaper's position, or manually introducing damage to the scene using methods like <a class="el" href="class_louvre_1_1_l_view.html#a8df5c6de25280bb70026359eb3050b73" title="Forces a complete repaint of the view in the next rendering frame.">Louvre::LSceneView::damageAll()</a> or <a class="el" href="class_louvre_1_1_l_scene_view.html#a2246ef739df15596c1bec97cc555f7ad" title="Add specific damage areas to the scene view for a specific output.">Louvre::LSceneView::addDamage()</a>.</p>
<p>Delete the added lines to restore your compositor to its normal state.</p>
<h2><a class="anchor" id="autotoc_md166"></a>
Displaying Minimized Windows</h2>
<p>Let's continue with how to present minimized windows on our topbar. You can modify the minimized state of any surface, regardless of its role, using <a class="el" href="class_louvre_1_1_l_surface.html#a842fbbf544354ca39c400d0651c27977" title="Sets the minimized property.">Louvre::LSurface::setMinimized()</a> and get its current state with <a class="el" href="class_louvre_1_1_l_surface.html#a02788e60359675cce4314237d9aa6eb2" title="Minimized property.">Louvre::LSurface::minimized()</a>. Additionally, you can listen to changes in this property by overriding the <a class="el" href="class_louvre_1_1_l_surface.html#af6160ec0911aec529a68eb827717bb9f" title="Notifies about changes in the minimized state of the surface.">Louvre::LSurface::minimizedChanged()</a> virtual method.</p>
<blockquote class="doxtable">
<p>When you minimize a surface, all of its child surfaces are also minimized. </p>
</blockquote>
<p>Clients can only request to minimize toplevels tho through <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a14e219a073b1d4559be6e781ccfd3536" title="Minimize request.">Louvre::LToplevelRole::setMinimizedRequest()</a>. Typically, this request occurs when a user interacts with the toplevel, such as clicking the minimize button or using a shortcut like <code>Ctrl + M</code>. In these cases, the client itself initiates the request. Interestingly, they can only request to minimize a surface but not to unminimize it (check the <a href="https://wayland.app/protocols/xdg-shell#xdg_toplevel:request:set_minimized">XDG Shell protocol</a>).</p>
<p>Various methods exist to display a thumbnail of a surface in the topbar view. One approach could be to create an additional view for the surface or its texture, positioning it within the topbar view, and then applying scaling using <a class="el" href="class_louvre_1_1_l_texture_view.html#a51848900154ff8caa92902d1662c4d42" title="Set the custom destination size of the LTextureView.">Louvre::LTextureView::setDstSize()</a> or <a class="el" href="class_louvre_1_1_l_view.html#a90cae3d55136e74ab30ab63dfb11672e" title="Sets the scalingVector() property.">Louvre::LView::setScalingVector()</a>. However, this approach can present challenges, especially with clients like Firefox, which use multiple surface layers for a single window. For instance, Firefox employs a toplevel surface for window decorations and a child subsurface for displaying browser content. Managing and scaling each surface properly in such cases, especially with significant downscaling, can lead to precision loss and a less than ideal appearance.</p>
<p>Another recommended approach, which I'll guide you through, involves creating a temporary <a class="el" href="class_louvre_1_1_l_scene_view.html" title="View for rendering other views.">Louvre::LSceneView</a>. Each <a class="el" href="class_louvre_1_1_l_scene_view.html" title="View for rendering other views.">Louvre::LSceneView</a> renders its content in its own framebuffer, allowing you to render all the necessary surfaces into that framebuffer and then create a downscaled copy to display in the topbar. Let's see how to achieve this.</p>
<p>To begin, we'll define the padding, margin, and height of the thumbnails in a macro located within the <code>Global.h</code> header. In addition, we will introduce an auxiliary method to facilitate the automatic casting of the <a class="el" href="class_louvre_1_1_l_compositor.html#a02b82f9077f93ed98b9fdd2c963014e8" title="Gets a list of all surfaces created by clients.">Louvre::LCompositor::surfaces()</a> lists into our custom subtype. Furthermore, we'll implement another method for relocating a surface view and all its child surfaces into another view, which will be used multiple times in the subsequent sections.</p>
<h3><a class="anchor" id="autotoc_md167"></a>
src/Global.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef G_H</span></div>
<div class="line"><span class="preprocessor">#define G_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LCompositor.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define TOPBAR_HEIGHT 32</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define TOPBAR_PADDING 4</span></div>
<div class="line"><span class="preprocessor">#define THUMBNAIL_MARGIN 4</span></div>
<div class="line"><span class="preprocessor">#define THUMBNAIL_HEIGHT (TOPBAR_HEIGHT - 2 * TOPBAR_PADDING)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ECompositor;</div>
<div class="line"><span class="keyword">class </span>EOutput;</div>
<div class="line"><span class="keyword">class </span>ESurface;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>G</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> std::list&lt;ESurface*&gt; &amp;surfaces()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> (std::list&lt;ESurface*&gt;&amp;)LCompositor::compositor()-&gt;surfaces();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> reparentSurfaceAndChildrenViews(ESurface *surface, LView *newParent, <span class="keywordtype">bool</span> subsurfaceRoleOnly = <span class="keyword">false</span>);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// G_H</span></div>
</div><!-- fragment --><p>We define the thumbnails height as the topbar height minus twice the topbar padding.</p>
<h3><a class="anchor" id="autotoc_md168"></a>
src/Global.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ECompositor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ESurface.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> G::reparentSurfaceAndChildrenViews(ESurface *surface, LView *newParent, <span class="keywordtype">bool</span> subsurfaceRoleOnly)</div>
<div class="line">{</div>
<div class="line">    surface-&gt;view.setParent(newParent);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The children of a surface are always positioned after their parent in the LCompositor::surfaces() list.</span></div>
<div class="line">    ESurface *next { surface };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (subsurfaceRoleOnly)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">while</span> ((next = (ESurface*)next-&gt;nextSurface()))</div>
<div class="line">            <span class="keywordflow">if</span> (next-&gt;isSubchildOf(surface) &amp;&amp; next-&gt;subsurface())</div>
<div class="line">                next-&gt;view.setParent(newParent);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">while</span> ((next = (ESurface*)next-&gt;nextSurface()))</div>
<div class="line">            <span class="keywordflow">if</span> (next-&gt;isSubchildOf(surface))</div>
<div class="line">                next-&gt;view.setParent(newParent);</div>
<div class="line">}</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>Note that if the <code>subsurfaceRoleOnly</code> parameter is set to <code>true</code>, only child surfaces with the <a class="el" href="class_louvre_1_1_l_subsurface_role.html" title="Subsurface role for surfaces.">Louvre::LSubsurfaceRole</a> are moved into the <code>newParent</code>. This is because surfaces with the <a class="el" href="class_louvre_1_1_l_subsurface_role.html" title="Subsurface role for surfaces.">Louvre::LSubsurfaceRole</a> are typically thought to be composited with their parent surface as if they were one. On the other hand, child popups and toplevels typically represent context menus and dialog windows respectively, so we want to exclude those when generating our thumbnails. </p>
</blockquote>
<p>Now, let's proceed to create an <a class="el" href="class_louvre_1_1_l_texture_view.html" title="View for displaying textures.">Louvre::LTextureView</a> subclass to serve as our thumbnail views, which we'll name <code>EThumbnail</code>.</p>
<h3><a class="anchor" id="autotoc_md169"></a>
src/EThumbnail.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ETHUMBNAIL_H</span></div>
<div class="line"><span class="preprocessor">#define ETHUMBNAIL_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LTextureView.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ETopbar;</div>
<div class="line"><span class="keyword">class </span>ESurface;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EThumbnail : <span class="keyword">public</span> LTextureView</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EThumbnail(ETopbar *topbar, ESurface *surface);</div>
<div class="line">    ETopbar  *topbar;</div>
<div class="line">    ESurface *surface;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// ETHUMBNAIL_H</span></div>
</div><!-- fragment --><p>It accepts two arguments: the topbar in which it will be embedded and the minimized surface it represents.</p>
<h3><a class="anchor" id="autotoc_md170"></a>
src/EThumbnail.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;EThumbnail.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ESurface.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ETopbar.h&quot;</span></div>
<div class="line"> </div>
<div class="line">EThumbnail::EThumbnail(ETopbar *topbar, ESurface *surface) :</div>
<div class="line">    LTextureView(surface-&gt;thumbnailTexture, &amp;topbar-&gt;view),</div>
<div class="line">    topbar(topbar),</div>
<div class="line">    surface(surface)</div>
<div class="line">{</div>
<div class="line">    surface-&gt;thumbnailViews.push_back(<span class="keyword">this</span>);</div>
<div class="line">    enableParentOpacity(<span class="keyword">false</span>);</div>
<div class="line">    setBufferScale(2);</div>
<div class="line">    topbar-&gt;updateGUI();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">EThumbnail::~EThumbnail()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* This is a handy function used for efficiently removing an element from a</span></div>
<div class="line"><span class="comment">     * vector where order isn&#39;t essential, employing the back-swap approach */</span></div>
<div class="line">    LVectorRemoveOneUnordered(surface-&gt;thumbnailViews, <span class="keyword">this</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Before calling updateGUI(), it&#39;s essential to remove it from the children</span></div>
<div class="line"><span class="comment">     * list of the topbar view to ensure proper ordering of the remaining thumbnails */</span></div>
<div class="line">    setParent(<span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">    topbar-&gt;updateGUI();</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the constructor, we set the surface thumbnail as the view texture (we'll cover how to create it shortly) and add it to the topbar view. Additionally, we add the item to the surface thumbails vector (we'll create it shortly too), set its buffer scale to 2 because the thumbnail textures will be high DPI, and we also disable the <a class="el" href="class_louvre_1_1_l_view.html#ad6193874aa0fb433c32260e2214853cd" title="Checks if the view&#39;s opacity is multiplied by its parent&#39;s opacity.">Louvre::LView::parentOpacityEnabled()</a> property, which prevents the views opacity to be affected by the topbar's opacity.</p>
<blockquote class="doxtable">
<p>By default, all views have their <a class="el" href="class_louvre_1_1_l_view.html#a64a46c0f9572b85ae118979de444e0f4" title="Gets the view opacity.">Louvre::LView::opacity()</a> set to 1.0 and the <a class="el" href="class_louvre_1_1_l_view.html#ad6193874aa0fb433c32260e2214853cd" title="Checks if the view&#39;s opacity is multiplied by its parent&#39;s opacity.">Louvre::LView::parentOpacityEnabled()</a> property enabled. This means that their opacities are multiplied by the opacity of their parent views. To prevent thumbnails from appearing translucent due to the semi-translucent top bar, we have disabled this feature. </p>
</blockquote>
<p>When the thumbnail is destroyed, we remove the item from the surface vector and the topbar view. This way, when <code>updateGUI()</code> is called, the remaining thumbnails will be properly re-ordered. Further clarification on these details will become apparent as we implement the remaining components.</p>
<blockquote class="doxtable">
<p>A view is automatically removed from its parent's children list when destroyed. Conversely, its <code><a class="el" href="class_louvre_1_1_l_view.html#a9cf5538b5398829274cfe35874e0e0da" title="Gets the parent of the view.">Louvre::LView::parent()</a></code> is automatically set to <code>nullptr</code> when the parent is destroyed. </p>
</blockquote>
<p>In the <code>updateGUI()</code> method of <code>ETopbar</code>, we now need to arrange the thumbnails from left to right, spacing them apart by a distance of <code>THUMBNAIL_MARGIN</code>.</p>
<h3><a class="anchor" id="autotoc_md171"></a>
src/ETopbar.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ETopbar.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EOutput.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EThumbnail.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ETopbar::updateGUI()</div>
<div class="line">{</div>
<div class="line">    view.setSize(output-&gt;size().w(), TOPBAR_HEIGHT);</div>
<div class="line">    view.setPos(output-&gt;pos());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> x { TOPBAR_PADDING };</div>
<div class="line">    <span class="keywordflow">for</span> (EThumbnail *thumbnail : (std::list&lt;EThumbnail*&gt;&amp;)view.children())</div>
<div class="line">    {</div>
<div class="line">        thumbnail-&gt;setPos(x, TOPBAR_PADDING);</div>
<div class="line">        x += thumbnail-&gt;size().w() + THUMBNAIL_MARGIN;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    output-&gt;repaint();</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_louvre_html_a20b0c262d9ef5d263888e463dfa99638"><div class="ttname"><a href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Louvre::Int32</a></div><div class="ttdeci">int32_t Int32</div><div class="ttdoc">32 bits signed integer</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:205</div></div>
</div><!-- fragment --><p>It's important to note that all views have the <a class="el" href="class_louvre_1_1_l_view.html#a73a566cebff0ad06de6133a61b164cc5" title="Checks if pos() includes the parent&#39;s position.">Louvre::LView::parentOffsetEnabled()</a> property enabled by default (as we already discussed), which means we're positioning the thumbnail views relative to the topbar view position.<br  />
 At the moment, we haven't encountered any issues with positioning views because they have all been children of the layers defined in <code>ECompositor</code>, which, by default, have a position of (0, 0).</p>
<p>Now, considering that the user of our compositor may have more than one screen, and we aim to display thumbnails in the top bar of each screen, we need to address the scenario where they are hotplugged on the fly. The straightforward approach is to simply copy the thumbnails from an already existing top bar, so lets implement that in <code>copyThumbnailsFromAnotherTopbar()</code>:</p>
<h3><a class="anchor" id="autotoc_md172"></a>
src/ETopbar.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ETopbar::copyThumbnailsFromAnotherTopbar()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (EOutput *o : G::outputs())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (o == output)</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (EThumbnail *item : (std::list&lt;EThumbnail *&gt;&amp;)o-&gt;topbar.view.children())</div>
<div class="line">            <span class="keyword">new</span> EThumbnail(<span class="keyword">this</span>, item-&gt;surface);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    updateGUI();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>Now, let's see how to create the thumbnails:</p>
<h3><a class="anchor" id="autotoc_md173"></a>
src/ESurface.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ESURFACE_H</span></div>
<div class="line"><span class="preprocessor">#define ESURFACE_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LSurface.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LSurfaceView.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ECompositor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EThumbnail;</div>
<div class="line"><span class="keyword">class </span>EOutput;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ESurface : <span class="keyword">public</span> LSurface</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ESurface(<span class="keyword">const</span> <span class="keywordtype">void</span> *params);</div>
<div class="line">    ~ESurface();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> roleChanged() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> orderChanged() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> minimizedChanged() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Output where the surface is currently most visible</span></div>
<div class="line">    EOutput *primaryOutput();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Take a snapshot of the surface</span></div>
<div class="line">    LTexture *capture(<span class="keyword">const</span> <a class="code" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp;dstSizeB);</div>
<div class="line"> </div>
<div class="line">    LSurfaceView view { (LSurface*) <span class="keyword">this</span>, &amp;G::compositor()-&gt;surfacesLayer };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Single texture shared by all thumbnail views</span></div>
<div class="line">    LTexture *thumbnailTexture { <span class="keyword">nullptr</span> };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Thumbnail views, one for each output&#39;s topbar</span></div>
<div class="line">    std::vector&lt;EThumbnail*&gt; thumbnailViews;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The output where the surface was most visible before being minimized</span></div>
<div class="line">    EOutput *outputBeforeMinimize { <span class="keyword">nullptr</span> };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The relative % surface position to outputBeforeMinimize</span></div>
<div class="line">    <a class="code" href="namespace_louvre.html#a5517b50113b8b1757430425847186df5">LPointF</a> relativePosBeforeMinimize;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// ESURFACE_H</span></div>
<div class="ttc" id="anamespace_louvre_html_a4df5473974ae0f28f3a4967f296a657b"><div class="ttname"><a href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">Louvre::LSize</a></div><div class="ttdeci">LPoint LSize</div><div class="ttdoc">2D vector of 32 bits integers</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:241</div></div>
<div class="ttc" id="anamespace_louvre_html_a5517b50113b8b1757430425847186df5"><div class="ttname"><a href="namespace_louvre.html#a5517b50113b8b1757430425847186df5">Louvre::LPointF</a></div><div class="ttdeci">LPointTemplate&lt; Float32 &gt; LPointF</div><div class="ttdoc">2D vector of 32 bits floats</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:244</div></div>
</div><!-- fragment --><p>In the <code>ESurface</code> class, several additions have been made:</p>
<p>Firstly, we've overridden the <a class="el" href="class_louvre_1_1_l_surface.html#af6160ec0911aec529a68eb827717bb9f" title="Notifies about changes in the minimized state of the surface.">Louvre::LSurface::minimizedChanged()</a> virtual method to listen for changes in the minimized state of a surface.</p>
<p>We've also introduced a new method called <code>primaryOutput()</code>, which will be used to determine the output in which the surface is most visible before it's minimized. Additionally, we'll store the position of the surface relative to that output as a percentage. This will allow us to restore the surface's position later even if the arrangement of outputs changes during the time it's minimized.</p>
<p>The <code>capture()</code> method will be used to render both the surface and its subsurfaces (<a class="el" href="class_louvre_1_1_l_subsurface_role.html" title="Subsurface role for surfaces.">Louvre::LSubsurfaceRole</a>) into a texture, which will serve as our thumbnail.</p>
<p>Lastly, the <code>thumbnailViews</code> vector will store all the minimized views for this surface, as we intend to create one for each initialized output (topbar).</p>
<h3><a class="anchor" id="autotoc_md174"></a>
Destructor</h3>
<p>In the destructor, we simply destroy the thumbnail texture and views associated with this surface. Remember that in the <code>EThumbnail</code> class destructor, we remove the item from the <code>thumbnailViews</code> vector.</p>
<h3><a class="anchor" id="autotoc_md175"></a>
src/ESurface.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;LCursor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ESurface.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EThumbnail.h&quot;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">ESurface::~ESurface()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">while</span> (!thumbnailViews.empty())</div>
<div class="line">        <span class="keyword">delete</span> thumbnailViews.back();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (thumbnailTexture)</div>
<div class="line">        <span class="keyword">delete</span> thumbnailTexture;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md176"></a>
primaryOutput()</h3>
<p>In this method, we calculate the area generated by intersecting the surface rect with each output rect and return the one where the area is the largest. If there is no intersection with any of them, we return <code>nullptr</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// ..</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;EOutput.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">EOutput *ESurface::primaryOutput()</div>
<div class="line">{</div>
<div class="line">    EOutput    *bestOutput   { <span class="keyword">nullptr</span> };</div>
<div class="line">    <a class="code" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>       bestArea     { 0 };</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespace_louvre.html#ad83fc7af7b313dac8820e4d4bd5b4383">LRect</a> surfaceRect  { rolePos(), size() };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Calculate the area of the surface intersected</span></div>
<div class="line"><span class="comment">     * with each output and return the one with the largest area */</span></div>
<div class="line">    <span class="keywordflow">for</span> (EOutput *output : G::outputs())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// We use LRegion to intersect both rects</span></div>
<div class="line">        LRegion tmpRegion;</div>
<div class="line">        tmpRegion.addRect(surfaceRect);</div>
<div class="line">        tmpRegion.<a class="code" href="class_louvre_1_1_l_rect_template.html#a1104d7b7123508c198359c5f5e6be8e7">clip</a>(output-&gt;rect());</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> LBox &amp;extents { tmpRegion.extents() };</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> area { (extents.x2 - extents.x1) * (extents.y2 - extents.y1) };</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (area &gt; bestArea)</div>
<div class="line">        {</div>
<div class="line">            bestArea = area;</div>
<div class="line">            bestOutput = output;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> bestOutput;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="aclass_louvre_1_1_l_rect_template_html_a1104d7b7123508c198359c5f5e6be8e7"><div class="ttname"><a href="class_louvre_1_1_l_rect_template.html#a1104d7b7123508c198359c5f5e6be8e7">Louvre::LRectTemplate::clip</a></div><div class="ttdeci">constexpr bool clip(const LRectTemplate&lt; N &gt; &amp;rect) noexcept</div><div class="ttdoc">Returns true if the resulting rectangle has an area of 0.</div><div class="ttdef"><b>Definition:</b> LRect.h:171</div></div>
<div class="ttc" id="anamespace_louvre_html_ad83fc7af7b313dac8820e4d4bd5b4383"><div class="ttname"><a href="namespace_louvre.html#ad83fc7af7b313dac8820e4d4bd5b4383">Louvre::LRect</a></div><div class="ttdeci">LRectTemplate&lt; Int32 &gt; LRect</div><div class="ttdoc">4D vector of 32 bits integers</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:250</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md177"></a>
capture()</h3>
<p>In the <code>capture()</code> method, we create a temporary <a class="el" href="class_louvre_1_1_l_scene_view.html" title="View for rendering other views.">Louvre::LSceneView</a> with a framebuffer size twice that of the surface and a scale factor of 2. This ensures the entire surface is captured and appears sharp on both low and high DPI displays. We deliberately refrain from assigning a parent to the scene view because its purpose is solely for offscreen rendering and does not need to be displayed in our main scene.</p>
<p>Instead of relocating the surface view and any subsurface views to the scene view's position, we position the scene view at the location of the surface view. This is feasible because, as a reminder, we have disabled the parent offset property for all surface views.</p>
<p>Subsequently, we designate the surface and subsurface views as children of the scene view using the auxiliary function defined in <code>Global.h</code>.</p>
<p>To render the views into the scene view framebuffer, we simply call <a class="el" href="class_louvre_1_1_l_scene_view.html#a8197074619887590f2ef9db4036838af" title="Render the scene.">Louvre::LSceneView::render()</a>.</p>
<p>Finally, we return the views to the surfaces layer and create a copy of the rendered scene view texture scaled to <code>dstSizeB</code>. For this, we use Louvre::LTexture::copyB(), allowing us to achieve high-quality downsampling.</p>
<h3><a class="anchor" id="autotoc_md178"></a>
src/ESurface.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">LTexture *ESurface::capture(<span class="keyword">const</span> LSize &amp;dstSizeB)</div>
<div class="line">{</div>
<div class="line">    LSceneView tmpSceneView {</div>
<div class="line">        size() * 2, <span class="comment">// Framebuffer size : x2 the surface size to make it look good on HiDPI displays.</span></div>
<div class="line">        2,          <span class="comment">// Scaling factor   : Affects how the children views are rendered</span></div>
<div class="line">        <span class="keyword">nullptr</span>     <span class="comment">// Parent view      : Not required because we are using it for offscreen rendering</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Instead of moving each view to the scene view, we move the scene to the views position.</span></div>
<div class="line"><span class="comment">     * This is why disabling parent offset is required. */</span></div>
<div class="line">    tmpSceneView.setPos(rolePos());</div>
<div class="line"> </div>
<div class="line">    G::reparentSurfaceAndChildrenViews(<span class="keyword">this</span>, &amp;tmpSceneView, <span class="keyword">true</span>);</div>
<div class="line">    tmpSceneView.render();</div>
<div class="line">    G::reparentSurfaceAndChildrenViews(<span class="keyword">this</span>, &amp;G::compositor()-&gt;surfacesLayer, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> tmpSceneView.texture()-&gt;copyB(</div>
<div class="line">        dstSizeB, <span class="comment">// Destination size in buffer coordiantes</span></div>
<div class="line">        <a class="code" href="namespace_louvre.html#ad83fc7af7b313dac8820e4d4bd5b4383">LRect</a>(),  <span class="comment">// Passing an empty src rect means copying the entire texture</span></div>
<div class="line">        <span class="keyword">true</span>      <span class="comment">// Enable high quality downscaling</span></div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md179"></a>
minimizedChanged()</h3>
<p>In <a class="el" href="class_louvre_1_1_l_surface.html#af6160ec0911aec529a68eb827717bb9f" title="Notifies about changes in the minimized state of the surface.">Louvre::LSurface::minimizedChanged()</a>, we take the following actions:</p>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LSeat.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LKeyboard.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LPointer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ESurface::minimizedChanged()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* When a surface is minimized, all its children are also minimized</span></div>
<div class="line"><span class="comment">     * we only want to display toplevels in the topbar so we ignore the rest */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!toplevel())</div>
<div class="line">        <span class="keywordflow">goto</span> toggleVisibility;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (minimized())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// We don&#39;t want the surface to continue receiving input events while minimized</span></div>
<div class="line">        <span class="keywordflow">if</span> (hasPointerFocus())</div>
<div class="line">            <a class="code" href="namespace_louvre.html#acee23df69aa55d791385fb9813b0319a">seat</a>()-&gt;<a class="code" href="class_louvre_1_1_l_seat.html#a2f468ca3b8e084c974a71175d3aedd7e">pointer</a>()-&gt;<a class="code" href="class_louvre_1_1_l_pointer.html#a1a7b38f151d09f7b336eceb92abd6ae8">setFocus</a>(<span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (hasKeyboardFocus())</div>
<div class="line">            <a class="code" href="namespace_louvre.html#acee23df69aa55d791385fb9813b0319a">seat</a>()-&gt;<a class="code" href="class_louvre_1_1_l_seat.html#a19552077a05ac0eb6fd9dc619c5a27a1">keyboard</a>()-&gt;<a class="code" href="class_louvre_1_1_l_keyboard.html#ab600af38a7a8579ddcaf35c4b2efee49">setFocus</a>(<span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Save the current surface position relative to the output position as a percentage so we can restore</span></div>
<div class="line"><span class="comment">         * it later even if the outputs arrangement changes or the given output is no longer available */</span></div>
<div class="line">        <span class="keywordflow">if</span> ( (outputBeforeMinimize = primaryOutput()) )</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="namespace_louvre.html#a5517b50113b8b1757430425847186df5">LPointF</a> localPos { pos() - outputBeforeMinimize-&gt;pos() };</div>
<div class="line">            relativePosBeforeMinimize = localPos / <a class="code" href="namespace_louvre.html#aaa9c675cb1cb28194c0deaf19e1be80e">LSizeF</a>(outputBeforeMinimize-&gt;size());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* In case the surface is not visible on any output, we select the first available output and position</span></div>
<div class="line"><span class="comment">         * the surface at 1/4 of the output as a fallback */</span></div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!G::outputs().empty())</div>
<div class="line">        {</div>
<div class="line">            outputBeforeMinimize = G::outputs().front();</div>
<div class="line">            relativePosBeforeMinimize = <a class="code" href="namespace_louvre.html#a5517b50113b8b1757430425847186df5">LPointF</a>(0.25f, 0.25f);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            setMinimized(<span class="keyword">false</span>);</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> thumbnailSizeB {</div>
<div class="line">            2 * (THUMBNAIL_HEIGHT * size().w()) / size().<a class="code" href="class_louvre_1_1_l_point_template.html#af25a41471a64f75cb28e9753864038fc">h</a>(),</div>
<div class="line">            2 * THUMBNAIL_HEIGHT</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        thumbnailTexture = capture(thumbnailSizeB);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (EOutput *output : G::outputs())</div>
<div class="line">            <span class="keyword">new</span> EThumbnail(&amp;output-&gt;topbar, <span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// If nullptr, then it was uninitialized while the surface was minimized</span></div>
<div class="line">        <span class="keywordflow">if</span> (!outputBeforeMinimize)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (!G::outputs().empty())</div>
<div class="line">            {</div>
<div class="line">                outputBeforeMinimize = G::outputs().front();</div>
<div class="line">                relativePosBeforeMinimize = <a class="code" href="namespace_louvre.html#a5517b50113b8b1757430425847186df5">LPointF</a>(0.25f, 0.25f);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Bye bye thumbnails</span></div>
<div class="line">        <span class="keywordflow">while</span> (!thumbnailViews.empty())</div>
<div class="line">            <span class="keyword">delete</span> thumbnailViews.front();</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">delete</span> thumbnailTexture;</div>
<div class="line">        thumbnailTexture = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Restore back the previous unminimized position</span></div>
<div class="line">        setPos(outputBeforeMinimize != <span class="keyword">nullptr</span> ? outputBeforeMinimize-&gt;pos() + (relativePosBeforeMinimize * outputBeforeMinimize-&gt;size()) : <a class="code" href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">LPoint</a>(0, TOPBAR_HEIGHT));</div>
<div class="line">        outputBeforeMinimize = <span class="keyword">nullptr</span>;</div>
<div class="line">        <span class="keyword">raise</span>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">toggleVisibility:</div>
<div class="line">    view.setVisible(!minimized());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="aclass_louvre_1_1_l_keyboard_html_ab600af38a7a8579ddcaf35c4b2efee49"><div class="ttname"><a href="class_louvre_1_1_l_keyboard.html#ab600af38a7a8579ddcaf35c4b2efee49">Louvre::LKeyboard::setFocus</a></div><div class="ttdeci">void setFocus(LSurface *surface)</div><div class="ttdoc">Set keyboard focus.</div><div class="ttdef"><b>Definition:</b> LKeyboard.cpp:274</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_point_template_html_af25a41471a64f75cb28e9753864038fc"><div class="ttname"><a href="class_louvre_1_1_l_point_template.html#af25a41471a64f75cb28e9753864038fc">Louvre::LPointTemplate::h</a></div><div class="ttdeci">constexpr T h() const noexcept</div><div class="ttdoc">Second component of the vector (equivalent to y())</div><div class="ttdef"><b>Definition:</b> LPoint.h:46</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_pointer_html_a1a7b38f151d09f7b336eceb92abd6ae8"><div class="ttname"><a href="class_louvre_1_1_l_pointer.html#a1a7b38f151d09f7b336eceb92abd6ae8">Louvre::LPointer::setFocus</a></div><div class="ttdeci">void setFocus(LSurface *surface, const LPoint &amp;localPos) noexcept</div><div class="ttdoc">Sets the pointer focus.</div><div class="ttdef"><b>Definition:</b> LPointer.cpp:47</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_seat_html_a19552077a05ac0eb6fd9dc619c5a27a1"><div class="ttname"><a href="class_louvre_1_1_l_seat.html#a19552077a05ac0eb6fd9dc619c5a27a1">Louvre::LSeat::keyboard</a></div><div class="ttdeci">LKeyboard * keyboard() const noexcept</div><div class="ttdoc">Access to keyboard events.</div><div class="ttdef"><b>Definition:</b> LSeat.h:111</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_seat_html_a2f468ca3b8e084c974a71175d3aedd7e"><div class="ttname"><a href="class_louvre_1_1_l_seat.html#a2f468ca3b8e084c974a71175d3aedd7e">Louvre::LSeat::pointer</a></div><div class="ttdeci">LPointer * pointer() const noexcept</div><div class="ttdoc">Access to pointer events.</div><div class="ttdef"><b>Definition:</b> LSeat.h:101</div></div>
<div class="ttc" id="anamespace_louvre_html_a1111511396cab1b2607e4ac55e1883a3"><div class="ttname"><a href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">Louvre::LPoint</a></div><div class="ttdeci">LPointTemplate&lt; Int32 &gt; LPoint</div><div class="ttdoc">2D vector of 32 bits integers</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:238</div></div>
<div class="ttc" id="anamespace_louvre_html_aaa9c675cb1cb28194c0deaf19e1be80e"><div class="ttname"><a href="namespace_louvre.html#aaa9c675cb1cb28194c0deaf19e1be80e">Louvre::LSizeF</a></div><div class="ttdeci">LPointF LSizeF</div><div class="ttdoc">2D vector of 32 bits floats</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:247</div></div>
<div class="ttc" id="anamespace_louvre_html_acee23df69aa55d791385fb9813b0319a"><div class="ttname"><a href="namespace_louvre.html#acee23df69aa55d791385fb9813b0319a">Louvre::seat</a></div><div class="ttdeci">LSeat * seat() noexcept</div><div class="ttdoc">Gets the compositor's seat.</div><div class="ttdef"><b>Definition:</b> LCompositor.cpp:39</div></div>
</div><!-- fragment --><ol type="1">
<li>First, we check whether the surface is a toplevel. If it isn't, we skip it to ensure that only toplevel surfaces appear minimized in our topbar.</li>
<li><p class="startli">When <a class="el" href="class_louvre_1_1_l_surface.html#a02788e60359675cce4314237d9aa6eb2" title="Minimized property.">Louvre::LSurface::minimized()</a> returns <code>true</code>, indicating that the surface is minimized we:</p>
<p class="startli">a. Determine the output where the surface is currently most visible using <code>primaryOutput()</code>. This could yield <code>nullptr</code> if the surface is not visible in any output, although it's an unusual scenario. In such cases we fallback to the first available output.</p>
<p class="startli">b. Calculate the current surface position relative to the output and as a percentage of its size. This enables us to restore the surface's position when unminimizing it. If the surface wasn't visible in any output, we opt for the first initialized one and set the position to 1/4 of its size.</p>
<p class="startli">c. Use <code>capture()</code> to create the thumbnail texture.</p>
<p class="startli">d. Create a thumbnail view for each topbar (all sharing the same texture).</p>
</li>
<li><p class="startli">In the alternative case, when the surface is unminimized we:</p>
<p class="startli">a. Destroy the thumbnail views and texture.</p>
<p class="startli">b. Restore the view's prev position.</p>
<p class="startli">c. Raise the surface.</p>
</li>
</ol>
<p>The final step we need to take is to set the <code>outputBeforeMinimize</code> variable to another output if it is uninitialized while the surface is minimized. This ensures that the surface correctly handles unminimization in <a class="el" href="class_louvre_1_1_l_surface.html#af6160ec0911aec529a68eb827717bb9f" title="Notifies about changes in the minimized state of the surface.">Louvre::LSurface::minimizedChanged()</a> and prevents our compositor from crashing.</p>
<p>So let's create a new method in <code>EOutput</code> named <code>rescueViewsFromVoid()</code>:</p>
<h3><a class="anchor" id="autotoc_md180"></a>
src/EOutput.h</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EOutput : <span class="keyword">public</span> LOutput</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> rescueViewsFromVoid();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md181"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;ESurface.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::rescueViewsFromVoid()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Search another initialized output</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> isDiff = [<span class="keyword">this</span>](<span class="keyword">const</span> EOutput *output) { <span class="keywordflow">return</span> <span class="keyword">this</span> != output; };</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> it { std::find_if(G::outputs().begin(), G::outputs().end(), isDiff) };</div>
<div class="line">    EOutput *fallbackOutput { it != G::outputs().end() ? *it : <span class="keyword">nullptr</span> };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (ESurface *surface : G::surfaces())</div>
<div class="line">        <span class="keywordflow">if</span> (surface-&gt;outputBeforeMinimize == <span class="keyword">this</span>)</div>
<div class="line">            surface-&gt;outputBeforeMinimize = fallbackOutput;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::uninitializeGL()</div>
<div class="line">{</div>
<div class="line">    rescueViewsFromVoid();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Note that if there were zero initialized outputs, in <a class="el" href="class_louvre_1_1_l_surface.html#af6160ec0911aec529a68eb827717bb9f" title="Notifies about changes in the minimized state of the surface.">Louvre::LSurface::minimizedChanged()</a>, we have already addressed the situation where a surface is unminimized, and <code>outputBeforeMinimize</code> is <code>nullptr</code>. </p>
</blockquote>
<p>After recompiling and running the compositor, you should now be able to minimize windows, and their thumbnails will appear on the top bar. Additionally, if you hotplug an output on the fly, you will observe the previously minimized surfaces automatically appearing on its respective top bar.</p>
<p><img src="https://lh3.googleusercontent.com/pw/ADCreHdClzn_FgEv67oYw4Hxmln3JkiUk9YRwITs1xIswKqiKOnMUvKNll6hTnIQJHw8W8Cd9YvJheZMqgYWXSBRzAo_YI_TP-KEp7zi8TdUp8rebLAaM3A=w2400" alt="" class="inline"/></p>
<p>Also, take the time to appreciate our dear biologist Humberto Maturana, may he rest in peace â¤ï¸.</p>
<p>One more thing you may have noticed is that we can only minimize windows but not unminimize them yet ðŸ˜„. In the next chapter, we'll delve into handling pointer events, which encompass input from devices like a mouse, touchpad, and more. We'll also explore how to unminimize the windows by clicking on their thumbnails.</p>
<p>Until next time!</p>
<p><a href="06.md">â—€ Chapter 6: Rendering with LScene and LViews</a> || <a href="08.md">Chapter 8: Pointer Events â–¶</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<script>
    var menu = false;
    var burger, nav;
    function resp()
    {
        if (window.innerWidth < 768)
        {
            burger.hidden = false;
            nav.hidden = true;
        }
        else
        {
            burger.hidden = true;
            nav.hidden = false;
        }
        menu = false;
    }
    function toggleMenu()
    {
        nav.hidden = menu;
        menu = !menu;
    }
    window.onload = function()
    {
        if (typeof toggleLevel !== "undefined")
            toggleLevel(2);
        // Get all <a> tags with the "el" class
        var elLinks = document.querySelectorAll('a.el');
        // Loop through the matched elements
        elLinks.forEach(function(link) 
        {
            // Replace "Louvre::" with an empty string in the text content
            link.textContent = link.textContent.replace(/Louvre::/g, '');
        });
        nav = document.getElementById('main-nav');
        burger = document.createElement('div');
        burger.style.position = 'absolute';
        burger.style.top = '14px';
        burger.style.right = burger.style.top;
        burger.innerHTML = '<svg onclick="toggleMenu()" height="32px" viewBox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg>';
        document.getElementById('top').appendChild(burger);
        resp();
    };
    window.onresize = function()
    {
        resp();
    };
</script>
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">Project developed by <a href="https://github.com/CuarzoSoftware"><img class="footer" src="https://avatars.githubusercontent.com/u/29326763?s=200&v=4" style="margin-left:2px;position:relative;top:-1px;width:12px;height:12px" alt="cuarzo"/> Cuarzo Software</a></li>
    </ul>
</div>